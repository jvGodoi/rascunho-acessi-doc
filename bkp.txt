import os
import asyncio
import time
import edge_tts
from flask import Flask, request, jsonify, send_from_directory, render_template
from PyPDF2 import PdfReader
from docx import Document
from langdetect import detect
from vozes import VOZES_MASCULINAS
import logging

# ↓ Opcional: silencia logs do servidor (Werkzeug) para manter só o log de tempo
logging.getLogger("werkzeug").setLevel(logging.ERROR)

app = Flask(__name__)
UPLOAD_FOLDER = 'uploads'
AUDIO_FOLDER = 'static/audio'
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(AUDIO_FOLDER, exist_ok=True)

# ===== Configs de performance do pipeline =====
MAX_CONCORRENCIA = 4        # nº de blocos convertidos em paralelo (ajuste se necessário)
TAMANHO_BLOCO = 4500        # caracteres por bloco (menos chamadas = mais rápido)
# =============================================

# Limpa texto
def limpar_texto(texto: str) -> str:
    return " ".join((texto or "").replace("\n", " ").split())

# Extrai texto
def extrair_texto(arquivo_path: str, extensao: str) -> str:
    if extensao == ".pdf":
        texto = ""
        leitor = PdfReader(arquivo_path)
        for pagina in leitor.pages:
            texto += (pagina.extract_text() or "") + "\n"
        return limpar_texto(texto)

    elif extensao == ".docx":
        doc = Document(arquivo_path)
        return limpar_texto("\n".join([p.text for p in doc.paragraphs]))

    elif extensao == ".txt":
        with open(arquivo_path, 'r', encoding='utf-8') as f:
            return limpar_texto(f.read())

    return ""

# Divide em blocos
def dividir_em_blocos(texto: str, max_caracteres: int = TAMANHO_BLOCO):
    palavras = texto.split()
    blocos, bloco = [], ""
    for p in palavras:
        if len(bloco) + len(p) + 1 <= max_caracteres:
            bloco += " " + p
        else:
            blocos.append(bloco.strip())
            bloco = p
    if bloco:
        blocos.append(bloco.strip())
    return blocos

# Converte um bloco usando streaming para MP3 temporário
async def converter_bloco_streaming(indice: int, bloco: str, voz: str) -> tuple[int, str]:
    temp_name = f"temp_{indice}.mp3"
    com = edge_tts.Communicate(bloco, voice=voz)
    with open(temp_name, "wb") as f:
        async for chunk in com.stream():
            if chunk["type"] == "audio":
                f.write(chunk["data"])
            # Se quiser progresso por palavra:
            # elif chunk["type"] == "WordBoundary": pass
    return indice, temp_name

# PIPELINE: concorrência limitada + escrita incremental em ordem
async def converter_audio_pipeline(texto: str, voz: str, caminho_final: str, max_concorrencia: int = MAX_CONCORRENCIA):
    blocos = dividir_em_blocos(texto, max_caracteres=TAMANHO_BLOCO)
    if not blocos:
        # garante arquivo vazio se não houver texto (ou lance erro no caller)
        open(caminho_final, "wb").close()
        return

    sem = asyncio.Semaphore(max_concorrencia)

    async def tarefa(indice, bloco):
        async with sem:
            return await converter_bloco_streaming(indice, bloco, voz)

    tarefas = [asyncio.create_task(tarefa(i, b)) for i, b in enumerate(blocos)]

    prox_indice = 0
    buffer = {}

    with open(caminho_final, "wb") as final_out:
        for coro in asyncio.as_completed(tarefas):
            indice, temp_path = await coro
            buffer[indice] = temp_path

            # Escreve em cascata mantendo a ordem correta (0,1,2,...)
            while prox_indice in buffer:
                path = buffer.pop(prox_indice)
                with open(path, "rb") as f_in:
                    final_out.write(f_in.read())
                os.remove(path)
                prox_indice += 1

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/converter", methods=["POST"])
def converter():
    inicio = time.time()

    if "arquivo" not in request.files:
        return jsonify({"erro": "Nenhum arquivo enviado."}), 400

    arquivo = request.files["arquivo"]
    if not arquivo.filename:
        return jsonify({"erro": "Nome de arquivo inválido."}), 400

    extensao = os.path.splitext(arquivo.filename)[1].lower()
    if extensao not in [".pdf", ".docx", ".txt"]:
        return jsonify({"erro": "Formato de arquivo não suportado."}), 400

    caminho_arquivo = os.path.join(UPLOAD_FOLDER, arquivo.filename)
    arquivo.save(caminho_arquivo)

    try:
        texto = extrair_texto(caminho_arquivo, extensao)
    except Exception as e:
        return jsonify({"erro": f"Erro ao extrair texto: {str(e)}"}), 500

    if not texto.strip():
        return jsonify({"erro": "O arquivo está vazio ou não contém texto legível."}), 400

    try:
        idioma = detect(texto)
        voz = VOZES_MASCULINAS.get(idioma, "pt-BR-AntonioNeural")
    except Exception:
        voz = "pt-BR-AntonioNeural"

    nome_base = os.path.splitext(arquivo.filename)[0].replace(" ", "_")
    caminho_audio = os.path.join(AUDIO_FOLDER, f"{nome_base}.mp3")

    try:
        asyncio.run(converter_audio_pipeline(texto, voz, caminho_audio, max_concorrencia=MAX_CONCORRENCIA))
    except Exception as e:
        return jsonify({"erro": f"Erro ao gerar áudio: {str(e)}"}), 500

    fim = time.time()
    duracao = fim - inicio
    # Log único de tempo
    if duracao < 60:
        print(f"Tempo total para gerar o áudio: {duracao:.2f} segundos.")
    else:
        print(f"Tempo total para gerar o áudio: {duracao/60:.2f} minutos.")

    tamanho_audio = os.path.getsize(caminho_audio)
    return jsonify({
        "nome": arquivo.filename,
        "tamanho": tamanho_audio,
        "audio_url": f"/audio/{os.path.basename(caminho_audio)}"
    })

@app.route("/audio/<nome>")
def servir_audio(nome):
    return send_from_directory(AUDIO_FOLDER, nome)

if __name__ == "__main__":
    # debug desativado para não poluir o terminal com logs adicionais
    app.run(debug=False)
